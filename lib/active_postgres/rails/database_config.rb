require 'yaml'

module ActivePostgres
  module Rails
    class DatabaseConfig
      DEFAULT_ROLE = 'primary'.freeze

      def self.generate(environment = 'production', app_name: nil, config: nil)
        builder = Builder.new(environment, app_name: app_name, config: config)
        builder.build_connections
      end

      def self.render(environment = 'production', app_name: nil, config: nil)
        connections = generate(environment, app_name: app_name, config: config)
        render_yaml(environment, connections)
      end

      def self.render_yaml(environment, connections)
        output = "#{environment}:\n"
        connections.each do |role, config|
          output += "  #{role}:\n"
          output += render_hash(config, indent: 4)
        end
        output
      end

      def self.render_hash(hash, indent: 0)
        output = ''
        hash.each do |key, value|
          spaces = ' ' * indent
          if value.is_a?(Hash)
            output += "#{spaces}#{key}:\n"
            output += render_hash(value, indent: indent + 2)
          elsif value.to_s.include?('<%=')
            # Don't quote ERB tags
            output += "#{spaces}#{key}: #{value}\n"
          elsif value.is_a?(String)
            output += "#{spaces}#{key}: #{value}\n"
          elsif [true, false].include?(value)
            output += "#{spaces}#{key}: #{value}\n"
          elsif value.is_a?(Integer)
            output += "#{spaces}#{key}: #{value}\n"
          else
            output += "#{spaces}#{key}: #{value}\n"
          end
        end
        output
      end

      def self.render_partial(environment = 'production', app_name: nil, config: nil)
        <<~YAML
          # Generated by active_postgres. This file is evaluated via ERB from config/database.yml.
          # Update config/postgres.yml or the POSTGRES_* environment variables to change values.

          #{render(environment, app_name: app_name, config: config)}
        YAML
      end

      class Builder
        attr_reader :environment, :config, :app_name

        def initialize(environment, app_name: nil, config: nil)
          @environment = environment
          @app_name = normalize_app_name(app_name)
          @config = config || Configuration.load('config/postgres.yml', environment)
        end

        def build_connections
          connections = {
            'primary' => deep_merge(base_connection, primary_connection_overrides)
          }

          replica_config = replica_connection_overrides
          connections['primary_replica'] = deep_merge(base_connection, replica_config) if replica_config

          connections
        end

        private

        def base_connection
          {
            'adapter' => 'postgresql',
            'encoding' => 'unicode',
            'pool' => env_value('RAILS_MAX_THREADS', fallback: 5),
            'username' => env_value('POSTGRES_APP_USER', fallback: app_name),
            'password' => env_value('POSTGRES_APP_PASSWORD'),
            'variables' => {
              'statement_timeout' => env_value('POSTGRES_STATEMENT_TIMEOUT', fallback: '15s')
            }
          }
        end

        def primary_connection_overrides
          primary_config = {
            'database' => env_value('POSTGRES_DATABASE', fallback: default_database_name),
            'host' => env_value('POSTGRES_PRIMARY_HOST', fallback: config.primary_replication_host),
            'port' => env_value('POSTGRES_PRIMARY_PORT', fallback: 5432)
          }

          # Set application_name in variables, not at top level
          primary_config['variables'] = (primary_config['variables'] || {}).merge(
            'application_name' => env_value('POSTGRES_APPLICATION_NAME', fallback: "#{app_name}-primary")
          )

          primary_config
        end

        def replica_connection_overrides
          standby_host = config.standby_hosts.first
          return nil unless standby_host

          resolved_host = config.replication_host_for(standby_host)

          replica_config = {
            'database' => env_value('POSTGRES_DATABASE', fallback: default_database_name),
            'host' => env_value('POSTGRES_REPLICA_HOST', fallback: resolved_host),
            'port' => env_value('POSTGRES_REPLICA_PORT', fallback: 5432),
            'replica' => true,
            'role' => 'reading'
          }

          # Set application_name in variables, not at top level
          replica_config['variables'] = (replica_config['variables'] || {}).merge(
            'application_name' => env_value('POSTGRES_APPLICATION_NAME', fallback: "#{app_name}-replica")
          )

          replica_config
        end

        def env_value(name, fallback: nil)
          if fallback.nil?
            "<%= ENV['#{name}'] %>"
          elsif fallback.is_a?(String)
            "<%= ENV.fetch('#{name}') { '#{fallback}' } %>"
          else
            "<%= ENV.fetch('#{name}') { #{fallback} } %>"
          end
        end

        def normalize_app_name(custom_name)
          chosen = custom_name || ENV['BORING_APP_NAME'] || default_app_name
          chosen.to_s.tr('- ', '_')
        end

        def default_app_name
          if defined?(::Rails) && ::Rails.application
            ::Rails.application.class.module_parent_name.underscore
          else
            File.basename(Dir.pwd).tr('- ', '_')
          end
        rescue StandardError
          'app'
        end

        def default_database_name
          "#{app_name}_#{environment}"
        end

        def deep_merge(hash1, hash2)
          result = hash1.dup
          hash2.each do |key, value|
            result[key] = if result[key].is_a?(Hash) && value.is_a?(Hash)
                            deep_merge(result[key], value)
                          else
                            value
                          end
          end
          result
        end
      end
    end
  end
end
